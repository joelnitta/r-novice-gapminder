---
title: ベクトル化
teaching: 10
exercises: 15
source: Rmd
---

::::::::::::::::::::::::::::::::::::::: objectives

- Rにおけるベクトル化された操作を理解する。

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::: questions

- ベクトルのすべての要素に一度に操作を行うにはどうすればよいですか？

::::::::::::::::::::::::::::::::::::::::::::::::::

```{r, include=FALSE}
gapminder <- read.csv("data/gapminder_data.csv", header = TRUE)
library("ggplot2")
```

Rの関数のほとんどはベクトル化されており、ループを使用して各要素に対して1つずつ処理を行う必要なく、ベクトルのすべての要素に対して操作を実行します。
これにより、コードが簡潔で読みやすく、エラーが少なくなります。

```{r}
x <- 1:4
x * 2
```

乗算がベクトルの各要素に対して行われました。

2つのベクトルを加えることもできます：

```{r}
y <- 6:9
x + y
```

`x` の各要素が対応する `y` の要素と加算されました：

```{r, eval=FALSE}
x:  1  2  3  4
    +  +  +  +
y:  6  7  8  9
---------------
    7  9 11 13
```

次に、ループを使用して2つのベクトルを加算する方法を示します：

```{r}
output_vector <- c()
for (i in 1:4) {
  output_vector[i] <- x[i] + y[i]
}
output_vector
```

ベクトル化された操作を使用した出力と比較してください。

```{r}
sum_xy <- x + y
sum_xy
```

:::::::::::::::::::::::::::::::::::::::  challenge

## チャレンジ 1

`gapminder` データセットの `pop` 列を使用してみましょう。

`gapminder` データフレームに新しい列を作成し、
人口を100万人単位で表示してください。
データフレームの先頭または末尾を確認して、正しく動作したか確認してください。

:::::::::::::::  solution

## チャレンジ 1 の解答

`gapminder` データセットの `pop` 列を使用してみましょう。

`gapminder` データフレームに新しい列を作成し、
人口を100万人単位で表示してください。
データフレームの先頭または末尾を確認して、正しく動作したか確認してください。

```{r}
gapminder$pop_millions <- gapminder$pop / 1e6
head(gapminder)
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## チャレンジ 2

単一のグラフ上で、すべての国の人口（単位は100万人）を年に対してプロットしてください。
どの国がどれかを識別する必要はありません。

次に、中国、インド、インドネシアに対してのみグラフ化を行ってください。
こちらもどの国がどれかを識別する必要はありません。

:::::::::::::::  solution

## チャレンジ 2 の解答

人口（単位は100万人）を年に対してプロットして、プロットスキルをリフレッシュしましょう。

```{r ch2-sol, fig.alt="中国、インド、インドネシアの人口（単位は100万人）を年に対してプロットした散布図。国はラベル付けされていません。"}
ggplot(gapminder, aes(x = year, y = pop_millions)) +
 geom_point()
countryset <- c("China","India","Indonesia")
ggplot(gapminder[gapminder$country %in% countryset,],
       aes(x = year, y = pop_millions)) +
  geom_point()
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

比較演算子、論理演算子、多くの関数もまたベクトル化されています：

**比較演算子**

```{r}
x > 2
```

**論理演算子**

```{r}
a <- x > 3  # または、明確にするために a <- (x > 3)
a
```

:::::::::::::::::::::::::::::::::::::::::  callout

## ヒント：論理ベクトルの便利な関数

`any()` はベクトル内に1つでも `TRUE` が含まれていれば `TRUE` を返します。  
`all()` はベクトル内のすべての要素が `TRUE` の場合にのみ `TRUE` を返します。

::::::::::::::::::::::::::::::::::::::::::::::::::

ほとんどの関数はベクトルに対して要素ごとに操作を行います：

**関数**

```{r}
x <- 1:4
log(x)
```

ベクトル化された操作は行列の要素ごとにも動作します：

```{r}
m <- matrix(1:12, nrow=3, ncol=4)
m * -1
```

:::::::::::::::::::::::::::::::::::::::::  callout

## ヒント：要素ごとの積と行列積の違い

重要：`*` 演算子は要素ごとの積を行います！
行列積を行うには、`%*%` 演算子を使用する必要があります：

```{r}
m %*% matrix(1, nrow=4, ncol=1)
matrix(1:4, nrow=1) %*% matrix(1:4, ncol=1)
```

行列代数についての詳細は、[Quick-R のリファレンスガイド](https://www.statmethods.net/advstats/matrix.html) を参照してください。

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## チャレンジ 3

次の行列を使用して：

```{r}
m <- matrix(1:12, nrow=3, ncol=4)
m
```

以下を実行するとどうなるか予想してください：

1. `m ^ -1`
2. `m * c(1, 0, -1)`
3. `m > c(0, 20)`
4. `m * c(1, 0, -1, 2)`

出力が予想と違った場合は、ヘルパーに尋ねてください！

:::::::::::::::  solution

## チャレンジ 3 の解答

次の行列を使用して：

```{r}
m <- matrix(1:12, nrow=3, ncol=4)
m
```

以下を実行するとどうなるか予想してください：

1. `m ^ -1`

```{r, echo=FALSE}
m ^ -1
```

2. `m * c(1, 0, -1)`

```{r, echo=FALSE}
m * c(1, 0, -1)
```

3. `m > c(0, 20)`

```{r, echo=FALSE}
m > c(0, 20)
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## チャレンジ 4

次の分数列の合計を計算したいとします：

```{r, eval=FALSE}
 x = 1/(1^2) + 1/(2^2) + 1/(3^2) + ... + 1/(n^2)
```

これを手で書き出すのは面倒で、高い値の n に対しては不可能です。
ベクトル化を使用して、n=100 の場合の x を計算してください。
n=10,000 の場合の合計はどうなりますか？

:::::::::::::::  solution

## チャレンジ 4 の解答

次の分数列の合計を計算したいとします：

```{r, eval=FALSE}
 x = 1/(1^2) + 1/(2^2) + 1/(3^2) + ... + 1/(n^2)
```

これを手で書き出すのは面倒で、高い値の n に対しては不可能です。
ベクトル化を使用して、n=100 の場合の x を計算してください。
n=10,000 の場合はどうでしょうか？

```{r}
sum(1/(1:100)^2)
sum(1/(1:1e04)^2)
n <- 10000
sum(1/(1:n)^2)
```

同じ結果を関数を使用して得ることもできます：

```{r}
inverse_sum_of_squares <- function(n) {
  sum(1/(1:n)^2)
}
inverse_sum_of_squares(100)
inverse_sum_of_squares(10000)
n <- 10000
inverse_sum_of_squares(n)
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::  callout

## ヒント：長さが異なるベクトルに対する操作

長さが異なるベクトルに対しても操作を実行できます。
これは*リサイクル*と呼ばれるプロセスを通じて行われます。
このプロセスでは、小さいベクトルが自動的に繰り返されて大きいベクトルの長さに一致します。
大きいベクトルが小さいベクトルの倍数ではない場合、Rは警告を出します。

```{r}
x <- c(1, 2, 3)
y <- c(1, 2, 3, 4, 5, 6, 7)
x + y
```

ベクトル `x` はベクトル `y` の長さに一致するようにリサイクルされました：

```{r, eval=FALSE}
x:  1  2  3  1  2  3  1
    +  +  +  +  +  +  +
y:  1  2  3  4  5  6  7
-----------------------
    2  4  6  5  7  9  8
```

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::: keypoints

- ループの代わりにベクトル化された操作を使用する。

::::::::::::::::::::::::::::::::::::::::::::::::::


