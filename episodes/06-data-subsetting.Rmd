---
title: データの部分集合化
teaching: 35
exercises: 15
source: Rmd
---

::::::::::::::::::::::::::::::::::::::: objectives

- ベクトル、因子、行列、リスト、データフレームの部分集合化を学ぶ
- インデックス、名前、比較演算を使って個々の要素や複数の要素を抽出する方法を理解する
- さまざまなデータ構造から要素をスキップまたは削除する方法を習得する

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::: questions

- R でデータの部分集合をどのように扱うことができますか？

::::::::::::::::::::::::::::::::::::::::::::::::::

```{r, include=FALSE}
gapminder <- read.csv("data/gapminder_data.csv", header = TRUE)
```

R には強力な部分集合化のための演算子が数多く用意されています。それらを習得することで、あらゆる種類のデータセットで複雑な操作を簡単に行えるようになります。

あらゆる種類のオブジェクトを部分集合化するために 6 つの異なる方法があり、データ構造ごとに 3 種類の部分集合化演算子があります。

では、R の基本となる数値ベクトルを使って始めましょう。

```{r}
x <- c(5.4, 6.2, 7.1, 4.8, 7.5)
names(x) <- c('a', 'b', 'c', 'd', 'e')
x
```

:::::::::::::::::::::::::::::::::::::::::  callout

## アトミックベクトル

R では、文字列、数値、または論理値を含む単純なベクトルを *アトミックベクトル* と呼びます。これは、さらに単純化できないためです。

::::::::::::::::::::::::::::::::::::::::::::::::::

このようにダミーベクトルを作成しました。この中身をどのように取得するのでしょうか？

## インデックスを使用した要素のアクセス

ベクトルの要素を抽出するには、対応するインデックスを指定します（1 から始まります）：

```{r}
x[1]
```

```{r}
x[4]
```

角括弧 `[]` 演算子は関数であり、ベクトルや行列に対して「n 番目の要素を取得する」という意味を持ちます。

複数の要素を一度に取得することもできます：

```{r}
x[c(1, 3)]
```

またはベクトルの一部（スライス）を取得することも可能です：

```{r}
x[1:4]
```

`:` 演算子は左の値から右の値までの数値のシーケンスを生成します。

```{r}
1:4
c(1, 2, 3, 4)
```

同じ要素を複数回取得することもできます：

```{r}
x[c(1,1,3)]
```

ベクトルの長さを超えるインデックスを指定すると、R は欠損値を返します：

```{r}
x[6]
```

これは `NA` を含む長さ 1 のベクトルであり、名前も `NA` です。

0 番目の要素を要求すると、空のベクトルが返されます：

```{r}
x[0]
```

:::::::::::::::::::::::::::::::::::::::::  callout

## R のベクトルの番号付けは 1 から始まる

多くのプログラミング言語（C や Python など）では、ベクトルの最初の要素のインデックスは 0 です。一方、R では最初の要素は 1 です。

::::::::::::::::::::::::::::::::::::::::::::::::::

## 要素のスキップと削除

ベクトルのインデックスに負の数を使用すると、指定した要素を除くすべての要素が返されます：

```{r}
x[-2]
```

複数の要素をスキップすることも可能です：

```{r}
x[c(-1, -5)]  # または x[-c(1,5)]
```

:::::::::::::::::::::::::::::::::::::::::  callout

## ヒント: 演算の順序

ベクトルの一部をスキップしようとすると、新しい人はよく間違えます。例えば：

```{r, error=TRUE, eval=FALSE}
x[-1:3]
```

このコードは次のようなエラーを返します：

```{r, error=TRUE, echo=FALSE}
x[-1:3]
```

これは演算の順序が関係しています。`:` は実際には関数であり、最初の引数を `-1`、2 番目の引数を `3` としてシーケンスを生成します：`c(-1, 0, 1, 2, 3)`。

正しい解決策は、この関数呼び出しを括弧で囲み、`-` 演算子を結果に適用することです：

```{r}
x[-(1:3)]
```

::::::::::::::::::::::::::::::::::::::::::::::::::

ベクトルから要素を削除するには、結果を変数に再割り当てする必要があります：

```{r}
x <- x[-4]
x
```

:::::::::::::::::::::::::::::::::::::::  challenge

## チャレンジ 1

次のコードが与えられた場合：

```{r}
x <- c(5.4, 6.2, 7.1, 4.8, 7.5)
names(x) <- c('a', 'b', 'c', 'd', 'e')
print(x)
```

次の出力を生成する少なくとも 2 つの異なるコマンドを考え出してください：

```{r, echo=FALSE}
x[2:4]
```

2 つの異なるコマンドを見つけたら、隣の人と比較してみてください。異なる戦略を持っていましたか？

:::::::::::::::  solution

## チャレンジ 1 の解答

```{r}
x[2:4]
```

```{r}
x[-c(1,5)]
```

```{r}
x[c(2,3,4)]
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

## 名前によるサブセット

インデックスではなく名前を使って要素を抽出することができます：

```{r}
x <- c(a=5.4, b=6.2, c=7.1, d=4.8, e=7.5) # ベクトルにその場で名前を付ける
x[c("a", "c")]
```

これは、オブジェクトをサブセットする際に、通常より信頼性の高い方法です。  
サブセット操作を連続して行う場合、要素の位置が変わることがありますが、名前は常に変わりません！

## 他の論理演算を用いたサブセット {#logical-operations}

論理ベクトルを使ってサブセットを取ることもできます：

```{r}
x[c(FALSE, FALSE, TRUE, FALSE, TRUE)]
```

比較演算子（例：`>`、`<`、`==`）は論理ベクトルを生成するため、それを使ってベクトルを簡潔にサブセットできます。以下のステートメントは、前の例と同じ結果を返します。

```{r}
x[x > 7]
```

このステートメントを分解すると、まず `x>7` が評価されて論理ベクトル `c(FALSE, FALSE, TRUE, FALSE, TRUE)` が生成され、それに基づいて `x` の要素が選択されます。

名前によるインデックス操作を模倣するには、`==` を使うことができます（比較には `=` ではなく `==` を使用する必要がある点に注意）：

```{r}
x[names(x) == "a"]
```

:::::::::::::::::::::::::::::::::::::::::  callout

## ヒント: 複数の論理条件の結合

複数の論理条件を結合したい場合があります。たとえば、特定の範囲内の寿命を持つアジアまたはヨーロッパに位置するすべての国を見つけたいとします。このような場合、R では論理ベクトルを結合するための以下の演算子を使用できます：

- `&`（論理AND）: 左右がともに `TRUE` の場合に `TRUE` を返します。
- `|`（論理OR）: 左右のいずれか、または両方が `TRUE` の場合に `TRUE` を返します。

`&` や `|` の代わりに `&&` や `||` が使われることもありますが、これらはベクトルの最初の要素だけを見て残りを無視します。データ解析では、通常1文字の演算子（`&` や `|`）を使用し、2文字の演算子はプログラミング（ステートメントの実行を決定する際など）で使用してください。

- `!`（論理NOT）: `TRUE` を `FALSE` に、`FALSE` を `TRUE` に変換します。単一の条件（例：`!TRUE` は `FALSE` になる）や、ベクトル全体（例：`!c(TRUE, FALSE)` は `c(FALSE, TRUE)` になる）を否定できます。

また、単一のベクトル内の要素を比較するために、`all`（すべての要素が `TRUE` の場合に `TRUE` を返す）や `any`（1つ以上の要素が `TRUE` の場合に `TRUE` を返す）関数を使用できます。

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## チャレンジ 2

以下のコードを用いて：

```{r}
x <- c(5.4, 6.2, 7.1, 4.8, 7.5)
names(x) <- c('a', 'b', 'c', 'd', 'e')
print(x)
```

`x` から 4 より大きく 7 未満の値を返すサブセットコマンドを書いてください。

:::::::::::::::  solution

## チャレンジ 2 の解答

```{r}
x_subset <- x[x<7 & x>4]
print(x_subset)
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::  callout

## ヒント: 重複する名前

1つのベクトル内で複数の要素が同じ名前を持つことも可能です（データフレームでは、列名が重複することはありますが、行名は一意である必要があります）。以下の例を考えてみてください：

```{r}
x <- 1:3
x
names(x) <- c('a', 'a', 'a')
x
x['a']  # 最初の値のみを返す
x[names(x) == 'a']  # すべての値を返す
```

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::  callout

## ヒント: 演算子に関するヘルプを得る方法

演算子を引用符で囲むことで、ヘルプを検索できます：  
`help("%in%")` または `?"%in%"`。

::::::::::::::::::::::::::::::::::::::::::::::::::

## 名前付き要素をスキップする

名前付き要素をスキップまたは削除するのは少し難しいです。文字列を否定してスキップしようとすると、R は「文字列を否定する方法が分からない」というやや分かりにくいエラーを出します：

```{r}
x <- c(a=5.4, b=6.2, c=7.1, d=4.8, e=7.5) # もう一度その場でベクトルに名前を付ける
x[-"a"]
```

しかし、`!=`（等しくない）演算子を使用して論理ベクトルを構築すれば、望む動作を実現できます：

```{r}
x[names(x) != "a"]
```

複数の名前付きインデックスをスキップするのはさらに難しいです。例えば、`"a"` と `"c"` を削除しようとして次のように試みます：

```{r}
x[names(x)!=c("a","c")]
```

R は *何か* をしましたが、警告を出しており、それが示す通り *間違った結果* を返しました（`"c"` 要素がまだベクトルに含まれています）。

`!=` がこの場合に何を実際にしているのかは、非常に良い質問です。

### リサイクル

このコードの比較部分を見てみましょう：

```{r}
names(x) != c("a", "c")
```

`names(x)[3] != "c"` は明らかに偽なのに、なぜ R はこのベクトルの3番目の要素に `TRUE` を返すのでしょうか？  
`!=` を使用すると、R は左辺の各要素を右辺の対応する要素と比較しようとします。左辺と右辺の長さが異なる場合はどうなりますか？

![](fig/06-rmd-inequality.1.png){alt='不等式テスト'}

一方のベクトルがもう一方より短い場合、短いベクトルは *リサイクル* されます：

![](fig/06-rmd-inequality.2.png){alt='リサイクルによる不等式テストの結果'}

この場合、R は `c("a", "c")` を必要な回数だけ繰り返して `names(x)` と一致させます（例：`c("a","c","a","c","a")`）。  
再利用された `"a"` が `names(x)` の3番目の要素と一致しないため、`!=` の結果が `TRUE` になります。

リサイクルによりこのような間違いが発生するのを防ぐには `%in%` 演算子を使用します。この演算子は左辺の各要素について、右辺の中にその要素が存在するかどうかを確認します。今回は値を除外したいので、`!` 演算子も使用します：

```{r}
x[! names(x) %in% c("a","c") ]
```

:::::::::::::::::::::::::::::::::::::::  challenge

## チャレンジ 3

ベクトルの要素を、特定のリスト内のいずれかと一致させる操作は、データ解析で非常に一般的なタスクです。例えば、gapminder データセットには `country` と `continent` の変数がありますが、これらの間の情報は含まれていません。東南アジアの情報を抽出したいとします。このとき、どのようにして東南アジアのすべての国について `TRUE`、それ以外を `FALSE` とする論理ベクトルを作成しますか？

以下のデータを使用します：

```{r}
seAsia <- c("Myanmar","Thailand","Cambodia","Vietnam","Laos")
## エピソード2でダウンロードした gapminder データを読み込む
gapminder <- read.csv("data/gapminder_data.csv", header=TRUE)
## データフレームから `country` 列を抽出（詳細は後述）；
## factor を文字列に変換；
## 重複しない要素のみ取得
countries <- unique(as.character(gapminder$country))
```

以下の3つの方法を試し、それぞれがどのように（正しくない、または正しい方法で）動作するのか説明してください：

1. **間違った方法**（`==` のみを使用）  
2. **不格好な方法**（論理演算子 `==` と `|` を使用）  
3. **エレガントな方法**（`%in%` を使用）

:::::::::::::::  solution

## チャレンジ 3 の解答

- **間違った方法**  
  `countries==seAsia`  
  この方法では、警告（`"In countries == seAsia : 長いオブジェクトの長さが短いオブジェクトの長さの倍数ではありません"`）が表示され、誤った結果（すべて `FALSE` のベクトル）が返されます。これは、`seAsia` の再利用された値が正しい位置に一致しないためです。

- **不格好な方法**  
  以下のコードでは正しい値を得ることができますが、非常に冗長で扱いにくいです：

```{r, results="hide"}
 (countries=="Myanmar" | countries=="Thailand" |
 countries=="Cambodia" | countries == "Vietnam" | countries=="Laos")
```

または、`countries==seAsia[1] | countries==seAsia[2] | ...` のように記述します。  
リストが長い場合、さらに複雑になります。

- **エレガントな方法**  
  `countries %in% seAsia`  
  この方法は正確で、記述が簡単で可読性も高いです。

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

## 特殊値の扱い

R では、欠損値、無限値、未定義値を処理できない関数に出会うことがあります。  
そのようなデータをフィルタリングするために、以下の特殊な関数を使用できます：

- `is.na`：ベクトル、行列、またはデータフレーム内の `NA`（または `NaN`）を含む位置を返します。
- 同様に、`is.nan` と `is.infinite` は、それぞれ `NaN` と `Inf` に対応します。
- `is.finite`：`NA`、`NaN`、`Inf` を含まない位置を返します。
- `na.omit`：ベクトルからすべての欠損値を除外します。

## 因子のサブセット

ベクトルのサブセット方法を学んだところで、他のデータ構造のサブセットについて考えてみましょう。  
因子のサブセットは、ベクトルのサブセットと同じ方法で行えます。

```{r}
f <- factor(c("a", "a", "b", "c", "c", "d"))
f[f == "a"]
f[f %in% c("b", "c")]
f[1:3]
```

要素をスキップしても、そのカテゴリが因子レベルから削除されるわけではありません：

```{r}
f[-3]
```

## 行列のサブセット

行列は `[` 関数を使用してサブセットします。この場合、2つの引数を取り、1つ目は行、2つ目は列に適用されます：

```{r}
set.seed(1)
m <- matrix(rnorm(6*4), ncol=4, nrow=6)
m[3:4, c(3,1)]
```

行または列全体を取得する場合は、1つ目または2つ目の引数を空白のままにします：

```{r}
m[, c(3,4)]
```

1つの行または列のみを取得すると、結果が自動的にベクトルに変換されます：

```{r}
m[3,]
```

結果を行列として保持するには、*第3引数* を指定して `drop = FALSE` を設定します：

```{r}
m[3, , drop=FALSE]
```

行または列の外側をアクセスしようとすると、R はエラーをスローします：

```{r, error=TRUE}
m[, c(3,6)]
```

:::::::::::::::::::::::::::::::::::::::::  callout

## ヒント: 高次元配列

多次元配列の場合、`[` の各引数が次元に対応します。例えば、3次元配列の場合、最初の3つの引数が行、列、および深さ次元に対応します。

::::::::::::::::::::::::::::::::::::::::::::::::::

行列はベクトルであるため、1つの引数だけを使用してサブセットを取ることもできます：

```{r}
m[5]
```

これは通常あまり有用ではなく、読み取りづらい場合があります。ただし、行列がデフォルトで *列優先フォーマット* に配置されていることを理解するのに役立ちます。つまり、ベクトルの要素は列ごとに配置されます：

```{r}
matrix(1:6, nrow=2, ncol=3)
```

行ごとに行列を埋めたい場合は、`byrow=TRUE` を使用します：

```{r}
matrix(1:6, nrow=2, ncol=3, byrow=TRUE)
```

行列は、行および列のインデックスの代わりに、その行名および列名を使用してサブセットを取ることもできます。

:::::::::::::::::::::::::::::::::::::::  challenge

## チャレンジ 4

以下のコードを用いて：

```{r}
m <- matrix(1:18, nrow=3, ncol=6)
print(m)
```

1. 以下のコマンドのうち、11 と 14 を抽出するものはどれでしょうか？

A. `m[2,4,2,5]`  
B. `m[2:5]`  
C. `m[4:5,2]`  
D. `m[2,c(4,5)]`  

:::::::::::::::  solution

## チャレンジ 4 の解答

D



:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

## リストのサブセット

ここでは新しいサブセット演算子を紹介します。リストをサブセットするためには、3つの関数を使用します。これらは、原子ベクトルや行列を学ぶ際にも登場しました：`[`, `[[`, `$` です。

`[` を使用すると、常にリストが返されます。リストから要素を「抽出」するのではなく「サブセット」したい場合に使用します。

```{r}
xlist <- list(a = "Software Carpentry", b = 1:10, data = head(mtcars))
xlist[1]
```

このコードは、*1つの要素を含むリスト* を返します。

リストの要素は、原子ベクトルと同じ方法でサブセットできます。ただし、比較演算は再帰的ではなく、リスト内のデータ構造に基づいて条件が評価されるため、リスト内の個々の要素には適用されません。

```{r}
xlist[1:2]
```

リストの個々の要素を抽出するには、二重角括弧関数 `[[` を使用する必要があります。

```{r}
xlist[[1]]
```

この結果はリストではなくベクトルであることに注意してください。

複数の要素を一度に抽出することはできません：

```{r, error=TRUE}
xlist[[1:2]]
```

また、要素をスキップすることもできません：

```{r, error=TRUE}
xlist[[-1]]
```

ただし、名前を使用して要素をサブセットおよび抽出することは可能です：

```{r}
xlist[["a"]]
```

`$` 演算子は、名前で要素を抽出するための簡潔な記法を提供します：

```{r}
xlist$data
```

:::::::::::::::::::::::::::::::::::::::  challenge

## チャレンジ 5

以下のリストが与えられています：

```{r, eval=FALSE}
xlist <- list(a = "Software Carpentry", b = 1:10, data = head(mtcars))
```

リストとベクトルのサブセット方法を用いて、`xlist` から数字の 2 を抽出してください。  
ヒント：数字の 2 はリスト内の `"b"` に含まれています。

:::::::::::::::  solution

## チャレンジ 5 の解答

```{r}
xlist$b[2]
```

```{r}
xlist[[2]][2]
```

```{r}
xlist[["b"]][2]
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## チャレンジ 6

以下の線形モデルが与えられています：

```{r, eval=FALSE}
mod <- aov(pop ~ lifeExp, data=gapminder)
```

残差の自由度を抽出してください（ヒント：`attributes()` が役立ちます）。

:::::::::::::::  solution

## チャレンジ 6 の解答

```{r, eval=FALSE}
attributes(mod) ## `df.residual` は `mod` の名前の1つです
```

```{r, eval=FALSE}
mod$df.residual
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

## データフレーム

データフレームは内部的にはリストであることを覚えておきましょう。そのため、同様のルールが適用されます。ただし、データフレームは2次元のオブジェクトでもあります：

`[` に1つの引数を与える場合、リストと同様に動作し、それぞれのリスト要素が列に対応します。結果として得られるオブジェクトはデータフレームになります：

```{r}
head(gapminder[3])
```

同様に、`[[` を使用すると、*単一の列* を抽出します：

```{r}
head(gapminder[["lifeExp"]])
```

`$` 演算子は、列を名前で抽出するための便利なショートカットを提供します：

```{r}
head(gapminder$year)
```

2つの引数を与えると、`[` は行列と同じように動作します：

```{r}
gapminder[1:3,]
```

単一行をサブセットすると、結果はデータフレームになります（要素が混合型のためです）：

```{r}
gapminder[3,]
```

ただし、単一列をサブセットすると結果はベクトルになります（第3引数 `drop = FALSE` を指定することで変更可能）。

:::::::::::::::::::::::::::::::::::::::  challenge

## チャレンジ 7

以下の一般的なデータフレームサブセットエラーを修正してください：

1. 年 1957 の観測値を抽出する
  
  ```{r, eval=FALSE}
  gapminder[gapminder$year = 1957,]
  ```

2. 1列目から4列目以外のすべての列を抽出する
  
  ```{r, eval=FALSE}
  gapminder[,-1:4]
  ```

3. 寿命が80年以上の行を抽出する
  
  ```{r, eval=FALSE}
  gapminder[gapminder$lifeExp > 80]
  ```

4. 1行目と4列目、5列目（`continent` と `lifeExp`）を抽出する
  
  ```{r, eval=FALSE}
  gapminder[1, 4, 5]
  ```

5. 応用：年 2002 年と 2007 年の情報を含む行を抽出する
  
  ```{r, eval=FALSE}
  gapminder[gapminder$year == 2002 | 2007,]
  ```

:::::::::::::::  solution

## チャレンジ 7 の解答

以下の一般的なデータフレームサブセットエラーを修正：

1. 年 1957 の観測値を抽出する
  
  ```{r, eval=FALSE}
  # gapminder[gapminder$year = 1957,]
  gapminder[gapminder$year == 1957,]
  ```

2. 1列目から4列目以外のすべての列を抽出する
  
  ```{r, eval=FALSE}
  # gapminder[,-1:4]
  gapminder[,-c(1:4)]
  ```

3. 寿命が80年以上の行を抽出する
  
  ```{r, eval=FALSE}
  # gapminder[gapminder$lifeExp > 80]
  gapminder[gapminder$lifeExp > 80,]
  ```

4. 1行目と4列目、5列目（`continent` と `lifeExp`）を抽出する
  
  ```{r, eval=FALSE}
  # gapminder[1, 4, 5]
  gapminder[1, c(4, 5)]
  ```

5. 応用：年 2002 年と 2007 年の情報を含む行を抽出する
  
  ```{r, eval=FALSE}
  # gapminder[gapminder$year == 2002 | 2007,]
  gapminder[gapminder$year == 2002 | gapminder$year == 2007,]
  gapminder[gapminder$year %in% c(2002, 2007),]
  ```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Challenge 8

1. Why does `gapminder[1:20]` return an error? How does it differ from `gapminder[1:20, ]`?

2. Create a new `data.frame` called `gapminder_small` that only contains rows 1 through 9
  and 19 through 23. You can do this in one or two steps.

:::::::::::::::  solution

## Solution to challenge 8

1. `gapminder` is a data.frame so needs to be subsetted on two dimensions. `gapminder[1:20, ]` subsets the data to give the first 20 rows and all columns.

2. 
```{r}
gapminder_small <- gapminder[c(1:9, 19:23),]
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::: keypoints

- Indexing in R starts at 1, not 0.
- Access individual values by location using `[]`.
- Access slices of data using `[low:high]`.
- Access arbitrary sets of data using `[c(...)]`.
- Use logical operations and logical vectors to access subsets of data.

::::::::::::::::::::::::::::::::::::::::::::::::::


