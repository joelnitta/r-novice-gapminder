---
title: tidyr を使用したデータフレームの操作
teaching: 30
exercises: 15
source: Rmd
---

::::::::::::::::::::::::::::::::::::::: objectives

- '長い'データフレーム形式と'広い'データフレーム形式の概念を理解し、`tidyr` を使ってそれらを変換できるようになる。

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::: questions

- データフレームのレイアウトをどのように変更できますか？

::::::::::::::::::::::::::::::::::::::::::::::::::

```{r, include=FALSE}
gapminder <- read.csv("data/gapminder_data.csv", header = TRUE, stringsAsFactors = FALSE)
gap_wide <- read.csv("data/gapminder_wide.csv", header = TRUE, stringsAsFactors = FALSE)
```

研究者はしばしば、データフレームの形式を「広い」レイアウトから「長い」レイアウトに変換したり、その逆を行ったりします。「長い」レイアウトまたは形式では以下のような特徴があります：

- 各列が変数
- 各行が観測値

純粋な「長い」形式では、通常、1列が観測値の変数であり、他の列がID変数です。

「広い」形式では、各行がサイト/被験者/患者を表し、同じ種類のデータを含む複数の観測変数があります。これには、時間経過での繰り返し観測や複数の変数の観測（またはその両方の混合）が含まれます。「広い」形式のほうがデータ入力が簡単である場合や、一部のアプリケーションが「広い」形式を好む場合があります。ただし、`R` の多くの関数は「長い」形式のデータを想定して設計されています。このチュートリアルでは、元の形式に関係なく、データの形状を効率的に変換する方法を学びます。

![](fig/14-tidyr-fig1.png){alt='データフレームの「広い」形式と「長い」形式の違いを示す図'}

長いデータフレームと広いデータフレームのレイアウトは主に可読性に影響します。人間にとって「広い」形式は、形状のために画面上でより多くのデータを確認できるため、より直感的な場合があります。しかし、「長い」形式は機械可読性が高く、データベースの形式に近いです。データフレームのID変数はデータベースのフィールドに、観測変数はデータベースの値に似ています。

## 開始方法

まず、まだインストールしていない場合は以下を実行してください（前回のレッスンで`dplyr`をインストールした可能性があります）：

```{r, eval=FALSE}
#install.packages("tidyr")
#install.packages("dplyr")
```

パッケージをロードします：

```{r, message=FALSE}
library("tidyr")
library("dplyr")
```

まず、元の`gapminder`データフレームの構造を見てみましょう：

```{r}
str(gapminder)
```

:::::::::::::::::::::::::::::::::::::::  challenge

## チャレンジ 1

`gapminder` は純粋に「長い」形式、「広い」形式、または中間形式のどれですか？

:::::::::::::::  solution

## チャレンジ 1 の解答

元の `gapminder` データフレームは中間形式です。純粋に「長い」形式ではなく、複数の観測変数
（`pop`、`lifeExp`、`gdpPercap`）を持っています。

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

時々、`gapminder`データセットのように、複数種類の観測データを持つことがあります。これは純粋な「長い」形式と「広い」形式の間のどこかに位置します。このデータセットには3つの「ID変数」
（`continent`、`country`、`year`）と3つの「観測変数」(`pop`、`lifeExp`、`gdpPercap`)があります。この中間形式は、すべての観測値を1列にする純粋に「長い」形式ではありませんが、それでも好まれる場合があります。これは、すべての観測変数が異なる単位を持っているためです。

多くのRの関数は「長い」形式を想定していますが、**注意：** 一部のプロット関数は「広い」形式のほうがうまく機能する場合があります。

## pivot\_longer() を使用して「広い」形式から「長い」形式に変換

これまで、適切にフォーマットされた元の`gapminder`データセットを使用していましたが、「実際」のデータ（例：自分の研究データ）は通常、これほど整理されていません。ここでは、「広い」形式の`gapminder`データセットを使用します。

> 「広い」形式の`gapminder`データを[こちらのcsvファイルのリンク](data/gapminder_wide.csv)からダウンロードして、`data`フォルダに保存してください。

データファイルをロードして確認しましょう。注意：`continent`と`country`列をファクターにしたくないため、`read.csv()`の`stringsAsFactors`引数を使用して無効にします。

```{r}
gap_wide <- read.csv("data/gapminder_wide.csv", stringsAsFactors = FALSE)
str(gap_wide)
```

![](fig/14-tidyr-fig2.png){alt='gapminder データフレームの「広い」形式を示す図'}

この非常に「広い」データフレームを「長い」レイアウトに戻すには、`tidyr`パッケージの`pivot`関数の1つである`pivot_longer()`を使用します。この関数は、行数を増やして列数を減らすことによってデータセットを「長い」形式に変換します。

![](fig/14-tidyr-fig3.png){alt='pivot_longerがデータフレームを「広い」形式から「長い」形式に再編成する方法を示す図'}

```{r}
gap_long <- gap_wide %>%
  pivot_longer(
    cols = c(starts_with('pop'), starts_with('lifeExp'), starts_with('gdpPercap')),
    names_to = "obstype_year", values_to = "obs_values"
  )
str(gap_long)
```

ここでは、前回の`dplyr`レッスンで学んだパイピング構文を使用しています。実際、`tidyr`と`dplyr`の関数を組み合わせて使用することが可能です。

次に、`separate()`関数を使用して、文字列を複数の変数に分割します：

```{r}
gap_long <- gap_long %>% separate(obstype_year, into = c('obs_type', 'year'), sep = "_")
gap_long$year <- as.integer(gap_long$year)
```

:::::::::::::::::::::::::::::::::::::::  challenge

## チャレンジ 2

`gap_long` を使用して、大陸ごとの平均寿命、人口、GDP per capitaを計算してください。
**ヒント：** `dplyr`レッスンで学んだ`group_by()`と`summarize()`関数を使用してください。

:::::::::::::::  solution

## チャレンジ 2 の解答

```{r}
gap_long %>% group_by(continent, obs_type) %>%
   summarize(means=mean(obs_values))
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

## pivot\_wider() を使用して長い形式から中間形式へ

作業を確認するのは常に良いことです。それでは、2つ目の `pivot` 関数である `pivot_wider()` を使用して、観測変数を再び「広げ」てみましょう。`pivot_wider()` は `pivot_longer()` の逆で、データセットの列数を増やし、行数を減らすことでデータを「広い」形式に変換します。`pivot_wider()` を使用して、`gap_long` を元の中間形式または最も広い形式に変換できます。まずは中間形式から始めましょう。

`pivot_wider()` 関数には `names_from` と `values_from` 引数があります。

`names_from` には、広げたデータフレームで新しい出力列としてピボットされる列名を指定します。対応する値は、`values_from` 引数で指定された列から追加されます。

```{r}
gap_normal <- gap_long %>%
  pivot_wider(names_from = obs_type, values_from = obs_values)
dim(gap_normal)
dim(gapminder)
names(gap_normal)
names(gapminder)
```

これで、元の`gapminder`と同じ次元を持つ中間形式のデータフレーム`gap_normal`ができましたが、変数の順序が異なります。これを修正してから、`all.equal()` でチェックします。

```{r}
gap_normal <- gap_normal[, names(gapminder)]
all.equal(gap_normal, gapminder)
head(gap_normal)
head(gapminder)
```

ほとんど完成ですが、元のデータは`country`と`year`でソートされています。

```{r}
gap_normal <- gap_normal %>% arrange(country, year)
all.equal(gap_normal, gapminder)
```

素晴らしいですね！最も長い形式から中間形式に戻り、コードにエラーがないことを確認できました。

次に、最も長い形式から最も広い形式まで変換してみましょう。この広い形式では、`country`と`continent`をID変数として保持し、3つのメトリクス（`pop`、`lifeExp`、`gdpPercap`）と時間（`year`）にわたる観測値をピボットします。まず、新しい変数（時間\*メトリクスの組み合わせ）に適切なラベルを作成し、ID変数を統合して`gap_wide`を定義しやすくします。

```{r}
gap_temp <- gap_long %>% unite(var_ID, continent, country, sep = "_")
str(gap_temp)

gap_temp <- gap_long %>%
    unite(ID_var, continent, country, sep = "_") %>%
    unite(var_names, obs_type, year, sep = "_")
str(gap_temp)
```

`unite()` を使用して、`continent`、`country` を統合した単一のID変数を作成し、変数名を定義しました。これで、`pivot_wider()` に渡す準備が整いました。

```{r}
gap_wide_new <- gap_long %>%
  unite(ID_var, continent, country, sep = "_") %>%
  unite(var_names, obs_type, year, sep = "_") %>%
  pivot_wider(names_from = var_names, values_from = obs_values)
str(gap_wide_new)
```

:::::::::::::::::::::::::::::::::::::::  challenge

## チャレンジ 3

これをさらに一歩進めて、国、年、3つのメトリクスに基づいてピボットすることで、`gap_ludicrously_wide` フォーマットデータを作成してください。
**ヒント:** この新しいデータフレームには5行しかないはずです。

:::::::::::::::  solution

## チャレンジ 3 の解答

```{r}
gap_ludicrously_wide <- gap_long %>%
   unite(var_names, obs_type, year, country, sep = "_") %>%
   pivot_wider(names_from = var_names, values_from = obs_values)
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

これで素晴らしい「広い」形式のデータフレームができましたが、`ID_var` をより使いやすくするために、`separate()` を使用して2つの変数に分割します。

```{r}
gap_wide_betterID <- separate(gap_wide_new, ID_var, c("continent", "country"), sep="_")
gap_wide_betterID <- gap_long %>%
    unite(ID_var, continent, country, sep = "_") %>%
    unite(var_names, obs_type, year, sep = "_") %>%
    pivot_wider(names_from = var_names, values_from = obs_values) %>%
    separate(ID_var, c("continent","country"), sep = "_")
str(gap_wide_betterID)

all.equal(gap_wide, gap_wide_betterID)
```

行って戻るプロセスが完了しました！

## その他の素晴らしいリソース

- [R for Data Science](https://r4ds.hadley.nz/) （オンライン書籍）
- [データ整形チートシート](https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf) （PDFファイル）
- [tidyr 入門](https://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html) （オンラインドキュメント）
- [R と RStudio を使用したデータ整形](https://www.rstudio.com/resources/webinars/data-wrangling-with-r-and-rstudio/) （オンラインビデオ）

:::::::::::::::::::::::::::::::::::::::: keypoints

- データフレームのレイアウトを変更するために `tidyr` パッケージを使用する。
- `pivot_longer()` を使用して「広い」レイアウトから「長い」レイアウトに変換する。
- `pivot_wider()` を使用して「長い」レイアウトから「広い」レイアウトに変換する。

::::::::::::::::::::::::::::::::::::::::::::::::::


